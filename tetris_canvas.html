<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Canvas Tetris – Mobile-Ready</title>
  <style>
    :root {
      --bg-main: #0f1724;
      --bg-panel: #111d2e;
      --accent: #00b2ff;
      --text-light: #d9e4f5;
      --grid: #1b2c44;
      --btn-size: 56px;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0; height: 100vh; display: flex; align-items: center; justify-content: center;
      background: var(--bg-main); color: var(--text-light); font-family: "Inter", system-ui, sans-serif;
      user-select: none; touch-action: manipulation;
    }

    /* ---------- layout ---------- */
    .wrapper { display: flex; gap: 1.5rem; align-items: flex-start; max-width: 100vw; }
    canvas#tetris {
      background: #000a14; border: 3px solid #000c18; border-radius: 8px;
      box-shadow: 0 4px 12px rgba(0,0,0,.45); max-width: 100vw; height: auto;
    }

    .panel {
      background: var(--bg-panel); padding: 1rem 1.3rem; border-radius: 10px;
      display: flex; flex-direction: column; gap: .9rem; min-width: 220px;
      box-shadow: 0 4px 18px rgba(0,0,0,.5);
    }
    .panel h1 { font-size: 1.3rem; margin: 0; color: var(--accent); }
    .stat { display: flex; justify-content: space-between; font-weight: 600;
            background: rgba(255,255,255,.05); padding: .4rem .7rem; border-radius: 6px; }
    .preview-wrap { background: #000a14; border: 2px solid #000c18; border-radius: 6px;
                    display: flex; align-items: center; justify-content: center; height: 6rem; }
    #preview { width: 80px; height: 80px; }

    button#restart {
      margin-top: .4rem; background: var(--accent); border: none; color: #fff;
      padding: .65rem 1rem; font-weight: 600; border-radius: 8px; cursor: pointer;
      transition: filter .2s;
    }
    button#restart:hover { filter: brightness(1.15); }

    /* ----- touch controls (phones only) ----- */
    .touch-controls { display: none; width: 100%; justify-content: center;
                      flex-wrap: wrap; gap: .7rem; margin-top: 1rem; }
    .touch-controls button {
      background: var(--accent); width: var(--btn-size); height: var(--btn-size);
      border: none; border-radius: 50%; font-size: 1.4rem; font-weight: 700; color: #fff;
      box-shadow: 0 3px 9px rgba(0,0,0,.3); cursor: pointer;
    }
    .touch-controls button:active { filter: brightness(.9); }

    @media (max-width: 650px) {
      .wrapper { flex-direction: column; align-items: center; gap: 1rem; }
      .panel { width: 90vw; min-width: unset; }
      .touch-controls { display: flex; }
    }
  </style>
</head>
<body>
  <div class="wrapper">
    <canvas id="tetris"></canvas>

    <div class="panel">
      <h1>Tetris</h1>
      <div class="stat"><span>Score</span><span id="score">0</span></div>
      <div class="stat"><span>Level</span><span id="level">1</span></div>
      <div class="stat"><span>Lines</span><span id="lines">0</span></div>
      <div class="preview-wrap"><canvas id="preview"></canvas></div>
      <button id="restart">Restart</button>
    </div>
  </div>

  <!-- on-screen buttons (show on mobile) -->
  <div class="touch-controls">
    <button id="btnLeft">←</button>
    <button id="btnRotate">⟳</button>
    <button id="btnRight">→</button>
    <button id="btnDown">↓</button>
    <button id="btnHard">⏬</button>
  </div>

<script>
/* ===== constants & helpers ===== */
const ARENA_W = 12, ARENA_H = 20;
const COLORS = [null,'#FF7F00','#00C2FF','#19FF6C','#AD0DFF','#FF3B70','#FFE600','#3975FF'];
const GRID_COLOR = getComputedStyle(document.documentElement).getPropertyValue('--grid');
const BASE_INTERVAL = 700, MIN_INTERVAL = 50, STEP_PER_LEVEL = 60;

/* ===== canvas setup ===== */
const board = document.getElementById('tetris'), bctx = board.getContext('2d');
const preview = document.getElementById('preview'), pctx = preview.getContext('2d');
let BLOCK = 30;                                       // will be recalculated

function calcBlock() {
  const vw = Math.min(innerWidth, innerHeight * .56);
  return vw < 650 ? Math.floor(vw / (ARENA_W + 2)) : 30;
}
function resizeCanvas() {
  BLOCK = calcBlock();
  board.width = ARENA_W * BLOCK;
  board.height = ARENA_H * BLOCK;
  bctx.setTransform(BLOCK,0,0,BLOCK,0,0);

  preview.width = BLOCK*4; preview.height = BLOCK*4;
  pctx.setTransform(BLOCK/2,0,0,BLOCK/2,0,0);

  if (player.matrix) draw();
  if (next) drawPreview();
}
addEventListener('resize', resizeCanvas);

/* ===== utilities ===== */
const matrix = (w,h)=>Array.from({length:h},()=>Array(w).fill(0));
const rand = ()=>'ILJOTSZ'[Math.random()*7|0];
const pieces = {
  T:[[0,0,0],[1,1,1],[0,1,0]], O:[[2,2],[2,2]], L:[[0,3,0],[0,3,0],[0,3,3]],
  J:[[0,4,0],[0,4,0],[4,4,0]], I:[[0,5,0,0],[0,5,0,0],[0,5,0,0],[0,5,0,0]],
  S:[[0,6,6],[6,6,0],[0,0,0]], Z:[[7,7,0],[0,7,7],[0,0,0]]
};
const newPiece = t => JSON.parse(JSON.stringify(pieces[t]));   // deep copy

/* ===== game state ===== */
const arena = matrix(ARENA_W, ARENA_H);
const player = { pos:{x:0,y:0}, matrix:null, score:0, lines:0, level:1 };
let next = newPiece(rand());

/* ===== core funcs ===== */
function collide(ar,pl){
  for(let y=0;y<pl.matrix.length;y++)
    for(let x=0;x<pl.matrix[y].length;x++)
      if(pl.matrix[y][x] && (ar[y+pl.pos.y]?.[x+pl.pos.x] || x+pl.pos.x<0 || x+pl.pos.x>=ARENA_W || y+pl.pos.y>=ARENA_H))
        return true;
  return false;
}
function merge(ar,pl){ pl.matrix.forEach((r,y)=>r.forEach((v,x)=>{ if(v) ar[y+pl.pos.y][x+pl.pos.x]=v; })); }
function rotate(m,d){ for(let y=0;y<m.length;y++) for(let x=0;x<y;x++) [m[x][y],m[y][x]]=[m[y][x],m[x][y]]; d>0?m.forEach(r=>r.reverse()):m.reverse(); }
function sweep(){
  let rows=0;
  outer:for(let y=ARENA_H-1;y>=0;y--){
    for(let x=0;x<ARENA_W;x++) if(!arena[y][x]) continue outer;
    arena.splice(y,1); arena.unshift(Array(ARENA_W).fill(0)); rows++; y++;
  }
  if(rows){ player.lines+=rows; player.score+=rows*10; player.level=Math.floor(player.lines/4)+1; setSpeed(); }
}
function drawMatrix(ctx,m,{x:ox,y:oy}){ m.forEach((r,y)=>r.forEach((v,x)=>{ if(v){ ctx.fillStyle=COLORS[v]; ctx.fillRect(ox+x,oy+y,1,1); ctx.lineWidth=0.08; ctx.strokeStyle=GRID_COLOR; ctx.strokeRect(ox+x,oy+y,1,1);} })); }
function draw(){ bctx.fillStyle='#000a14'; bctx.fillRect(0,0,board.width,board.height); drawMatrix(bctx,arena,{x:0,y:0}); drawMatrix(bctx,player.matrix,player.pos); }
function drawPreview(){ pctx.clearRect(0,0,preview.width,preview.height); drawMatrix(pctx,next,{x:0.5,y:0.5}); }

function resetGame(){ arena.forEach(r=>r.fill(0)); Object.assign(player,{score:0,lines:0,level:1}); setSpeed(); }
function playerReset(){ player.matrix=next; next=newPiece(rand()); drawPreview(); player.pos.y=0; player.pos.x=(ARENA_W/2|0)-(player.matrix[0].length/2|0); if(collide(arena,player)) resetGame(); }

function playerMove(d){ player.pos.x+=d; if(collide(arena,player)) player.pos.x-=d; }
function playerRot(d){ rotate(player.matrix,d); if(collide(arena,player)) rotate(player.matrix,-d); }
function drop(){ player.pos.y++; if(collide(arena,player)){ player.pos.y--; merge(arena,player); sweep(); playerReset(); } dropCounter=0; }
function hardDrop(){ while(!collide(arena,player)) player.pos.y++; player.pos.y--; merge(arena,player); sweep(); playerReset(); dropCounter=0; }

/* ===== timers ===== */
let dropCounter=0,lastTime=0,interval=BASE_INTERVAL,fast=false,paused=false;
function setSpeed(){ interval=Math.max(MIN_INTERVAL,BASE_INTERVAL-(player.level-1)*STEP_PER_LEVEL); }
function loop(t=0){ if(paused){ requestAnimationFrame(loop); return; } const dt=t-lastTime; lastTime=t; dropCounter+=dt; if(dropCounter>(fast?60:interval)) drop(); draw(); requestAnimationFrame(loop); }

/* ===== HUD ===== */
const $=id=>document.getElementById(id);
setInterval(()=>{ ['score','level','lines'].forEach(id=>$(id).textContent=player[id]); },150);

/* ===== input ===== */
addEventListener('keydown',e=>{
  if(e.repeat) return;
  switch(e.code){
    case 'ArrowLeft': playerMove(-1); break;
    case 'ArrowRight': playerMove(1); break;
    case 'ArrowDown': fast=true; break;
    case 'KeyZ':
    case 'KeyX': playerRot(1); break;
    case 'Space': hardDrop(); break;
    case 'KeyP': paused=!paused; break;
  }
});
addEventListener('keyup',e=>{ if(e.code==='ArrowDown') fast=false; });

$('restart').addEventListener('click',()=>{ resetGame(); playerReset(); });

/* touch */
if($('btnLeft')){
  $('btnLeft' ).addEventListener('pointerdown',()=>playerMove(-1));
  $('btnRight').addEventListener('pointerdown',()=>playerMove(1));
  $('btnRotate').addEventListener('pointerdown',()=>playerRot(1));
  $('btnHard' ).addEventListener('pointerdown',hardDrop);
  $('btnDown' ).addEventListener('pointerdown',()=>fast=true);
  ['pointerup','pointercancel','pointerleave'].forEach(ev=>$('btnDown').addEventListener(ev,()=>fast=false));
}

/* ===== init ===== */
resizeCanvas();
playerReset();
setSpeed();
loop();
</script>
</body>
</html>
