<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Tetris Mobile</title>
  <style>
    :root {
      --bg-main:#0f1724;
      --accent:#00b2ff;
      --text:#e0e6f0;
      --grid:#39516f;
      --hud-h:52px;          /* status‑bar height */
      --btn-size:78px;       /* on‑screen button size */
    }
    *{box-sizing:border-box;margin:0;-webkit-user-select:none;user-select:none;}
    body{height:100vh;background:var(--bg-main);display:flex;flex-direction:column;align-items:center;color:var(--text);font-family:system-ui,sans-serif;touch-action:manipulation;}

    /* ---------- HUD ---------- */
    .hud{height:var(--hud-h);width:100%;max-width:720px;padding:0 .8rem;display:flex;justify-content:space-between;align-items:center;background:#111d2e;box-shadow:0 2px 6px #0008;font-weight:600;font-size:1.15rem;letter-spacing:.4px;}
    .hud span{flex:1;text-align:center;color:var(--accent);}  /* label */
    .hud strong{color:#fff;margin-left:.25rem;}

    /* ---------- playfield ---------- */
    #playfield{flex:1;width:100%;max-width:720px;background:#000a14;border:4px solid #000c18;border-top:none;box-shadow:0 4px 14px #000a;touch-action:none;}

    /* ---------- controls ---------- */
    .ctrl-btn{position:absolute;bottom:20px;border:none;border-radius:50%;width:var(--btn-size);height:var(--btn-size);font-size:2rem;font-weight:800;color:#fff;background:var(--accent);box-shadow:0 5px 14px rgba(0,0,0,.5);display:flex;align-items:center;justify-content:center;}
    .ctrl-btn:active{filter:brightness(.9);}  
    #btnDown{left:18px;}      /* soft‑drop (hold) */
    #btnRotate{right:18px;}    /* rotate */
  </style>
</head>
<body>
  <div class="hud">
    <span>Score<strong id="score">0</strong></span>
    <span>Level<strong id="level">1</strong></span>
    <span>Lines<strong id="lines">0</strong></span>
  </div>

  <canvas id="playfield"></canvas>
  <button id="btnDown"   class="ctrl-btn">↓</button>
  <button id="btnRotate" class="ctrl-btn">⟳</button>

<script>
/*****************  CONSTANTS  *****************/
const W=12, H=20, COLORS=[null,'#FF7F00','#00C2FF','#19FF6C','#AD0DFF','#FF3B70','#FFE600','#3975FF'];
const BASE=600, MIN=60, STEP=60; // drop speeds (ms)

/*****************  CANVAS  *****************/
const canvas=document.getElementById('playfield'), ctx=canvas.getContext('2d');
let BLOCK=30;        // dynamic cell size
function fitBoard(){
  BLOCK=Math.floor(innerWidth/W);
  BLOCK=Math.max(BLOCK,14); // ensure visibility
  canvas.width=W*BLOCK;
  canvas.height=H*BLOCK;
  ctx.setTransform(BLOCK,0,0,BLOCK,0,0);
  draw();
}
addEventListener('resize',fitBoard);

/*****************  HELPERS  *****************/
const newMatrix=(w,h)=>Array.from({length:h},()=>Array(w).fill(0));
const randType=_=>'ILJOTSZ'[Math.random()*7|0];
const templates={T:[[0,0,0],[1,1,1],[0,1,0]],O:[[2,2],[2,2]],L:[[0,3,0],[0,3,0],[0,3,3]],J:[[0,4,0],[0,4,0],[4,4,0]],I:[[0,5,0,0],[0,5,0,0],[0,5,0,0],[0,5,0,0]],S:[[0,6,6],[6,6,0],[0,0,0]],Z:[[7,7,0],[0,7,7],[0,0,0]]};
const clone=m=>m.map(r=>r.slice());

/*****************  GAME STATE  *****************/
const arena=newMatrix(W,H);
const player={pos:{x:0,y:0},matrix:null,score:0,lines:0,level:1};
let next=clone(templates[randType()]);

/*****************  CORE LOGIC  *****************/
function collide(){ for(let y=0;y<player.matrix.length;y++) for(let x=0;x<player.matrix[y].length;x++) if(player.matrix[y][x]){
  const px=x+player.pos.x, py=y+player.pos.y;
  if(px<0||px>=W||py>=H|| arena[py][px]) return true; } return false; }
function merge(){ player.matrix.forEach((r,y)=>r.forEach((v,x)=>{ if(v) arena[y+player.pos.y][x+player.pos.x]=v; })); }
function rotate(mat){ for(let y=0;y<mat.length;y++) for(let x=0;x<y;x++) [mat[x][y],mat[y][x]]=[mat[y][x],mat[x][y]]; mat.forEach(r=>r.reverse()); if(collide()) mat.forEach(r=>r.reverse()); }
function sweep(){ let rows=0; outer:for(let y=H-1;y>=0;--y){ for(let x=0;x<W;++x){ if(!arena[y][x]) continue outer; } arena.splice(y,1); arena.unshift(Array(W).fill(0)); rows++; ++y; }
  if(rows){ player.lines+=rows; player.score+=rows*10; player.level=Math.floor(player.lines/4)+1; interval=Math.max(MIN, BASE-(player.level-1)*STEP); }
}
function spawn(){ player.matrix=next; next=clone(templates[randType()]); player.pos.y=0; player.pos.x=(W>>1)-(player.matrix[0].length>>1); if(collide()) reset(); }
function reset(){ arena.forEach(r=>r.fill(0)); Object.assign(player,{score:0,lines:0,level:1}); interval=BASE; }

/*****************  DRAWING  *****************/
function drawCellGrid(){ ctx.lineWidth=0.04; ctx.strokeStyle=getComputedStyle(document.documentElement).getPropertyValue('--grid'); for(let y=0;y<H;y++) for(let x=0;x<W;x++){ ctx.strokeRect(x, y, 1,1); } }
function drawMatrix(m,o){ m.forEach((r,y)=>r.forEach((v,x)=>{ if(v){ ctx.fillStyle=COLORS[v]; ctx.fillRect(o.x+x, o.y+y,1,1); ctx.lineWidth=0.05; ctx.strokeStyle='#000'; ctx.strokeRect(o.x+x, o.y+y,1,1); } })); }
function draw(){ ctx.fillStyle='#000a14'; ctx.fillRect(0,0,canvas.width,canvas.height); drawCellGrid(); drawMatrix(arena,{x:0,y:0}); if(player.matrix) drawMatrix(player.matrix,player.pos); }

/*****************  LOOP  *****************/
let dropCounter=0, last=0, interval=BASE, fast=false;
function update(t=0){ const dt=t-last; last=t; dropCounter+=dt; if(dropCounter>(fast?80:interval)){ player.pos.y++; if(collide()){ player.pos.y--; merge(); sweep(); spawn(); } dropCounter=0; }
  draw(); requestAnimationFrame(update); }

/*****************  INPUT  *****************/
// Keyboard (desktop testing)
addEventListener('keydown',e=>{ if(e.repeat)return; switch(e.code){ case'ArrowLeft': move(-1); break; case'ArrowRight': move(1); break; case'ArrowDown': fast=true; break; case'Space': rotate(player.matrix); break; }});
addEventListener('keyup',e=>{ if(e.code==='ArrowDown') fast=false; });
function move(dir){ player.pos.x+=dir; if(collide()) player.pos.x-=dir; }

// Button controls
const btnDown=document.getElementById('btnDown'); const btnRot=document.getElementById('btnRotate');
btnDown.addEventListener('pointerdown',()=>fast=true);
['pointerup','pointerleave','pointercancel'].forEach(ev=>btnDown.addEventListener(ev,()=>fast=false));
btnRot.addEventListener('pointerdown',()=>rotate(player.matrix));

// Improved swipe: continuous drag
let dragStart=null;
canvas.addEventListener('touchstart',e=>{dragStart=e.touches[0].clientX;});
canvas.addEventListener('touchmove',e=>{ if(dragStart===null) return; const cx=e.touches[0].clientX; const dx=cx-dragStart; if(Math.abs(dx) > BLOCK*0.6){ const steps=Math.round(dx/BLOCK); move(steps); dragStart=cx; } });
canvas.addEventListener('touchend',e=>{ const t=e.changedTouches[0]; const dx=t.clientX-dragStart; const dy=t.clientY-e.changedTouches[0].clientY; if(Math.abs(dx)<10&&Math.abs(dy)<10) rotate(player.matrix); dragStart=null; });

/*****************  HUD  *****************/
setInterval(()=>{ document.getElementById('score').textContent=player.score; document.getElementById('level').textContent=player.level; document.getElementById('lines').textContent=player.lines; },150);

/*****************  INIT  *****************/
fitBoard(); spawn(); update();
</script>
</body>
</html>

